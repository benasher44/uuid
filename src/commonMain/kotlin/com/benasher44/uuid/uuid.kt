package com.benasher44.uuid

internal val UUID_BYTES = 16
internal val UUID_STRING_LENGTH = 36

@Deprecated("Use `Uuid` instead.", ReplaceWith("Uuid"))
public typealias UUID = Uuid

/**
 * A v4 RFC4122 UUID
 *
 * @property uuid The underlying UUID bytes
 * @constructor Constructs a new UUID from the given ByteArray; by default uses randomly generated bytes
 * @throws IllegalArgumentException, if uuid.count() is not 16
 * */
public class Uuid(val uuid: ByteArray = genUuid()) {
    /** The 64 most significant bits of this [UUID]. */
    public val msb: Long
        get() = (0..7).fold(0L) { bits, i -> bits shl 8 or (uuid[i].toLong() and 0xff) }

    /** The 64 most significant bits of this [UUID]. */
    public val lsb: Long
        get() = (0..15).fold(0L) { bits, i -> bits shl 8 or (uuid[i].toLong() and 0xff) }

    /** @see msb */
    @Deprecated("Use the short `msb` form instead.", ReplaceWith("msb"))
    public inline val mostSignificantBits: Long
        get() = msb

    /** @see lsb */
    @Deprecated("Use the short `lsb` form instead.", ReplaceWith("lsb"))
    /** The least significant 64 bits of this UUID's 128 bit value. */
    public inline val leastSignificantBits: Long
        get() = lsb

    /**
     * The version number describes how this [Uuid] was generated.
     *
     * Possible values:
     * 1 => Time-based
     * 2 => DCE security
     * 3 => Name-based
     * 4 => Randomly generated
     *
     * @return The version number associated with this [Uuid]
     */
    val version: Int by lazy { ((msb shr 12) and 0x0f).toInt() }

    /**
     * The variant number describes the layout of the [Uuid].
     *
     * Possible values:
     * 0 => Reserved for NCS backward compatibility
     * 2 => IETF RFC 4122 (Leach-Salz)
     * 6 => Reserved, Microsoft Corporation backward compatibility
     * 7 => Reserved for future definition
     *
     * @return The variant number associated with this [Uuid]
     */
    val variant: Int by lazy { (lsb.ushr((64 - (lsb ushr 62)).toInt()) and (lsb shr 63)).toInt() }

    init {
        if (uuid.count() != UUID_BYTES) {
            throw IllegalArgumentException(
                "Invalid UUID bytes. Expected $UUID_BYTES bytes; found ${uuid.count()}"
            )
        }
        this.freeze()
    }
    companion object {

        /** Generates a random UUID */
        private fun genUuid(): ByteArray {
            val bytes = getRandomUuidBytes()
            // Set the version bit
            bytes[6] = ((bytes[6].toInt() and 0x0F) or 0x40).toByte()

            // Set the 0 and 1 bits
            bytes[8] = ((bytes[8].toInt() and 0b00111111) or 0b10000000).toByte()
            return bytes
        }

        // Ranges of non-hyphen characters in a UUID string
        internal val uuidCharRanges: List<IntRange> = listOf(
            0 until 8,
            9 until 13,
            14 until 18,
            19 until 23,
            24 until 36
        )

        // Indices of the hyphen characters in a UUID string
        internal val hyphenIndices = listOf(8, 13, 18, 23)

        /** @returns the Int representation of a given UUID character */
        private fun halfByteFromChar(char: Char) = when (char) {
            in '0'..'9' -> char.toInt() - 48
            in 'a'..'f' -> char.toInt() - 87
            in 'A'..'F' -> char.toInt() - 55
            else -> null
        }

        /**
         * Parses a UUID from a String
         *
         * @param from The String, from which to deserialize the UUID
         * @return a UUID, if the string is a valid UUID string
         */
        fun parse(from: String): Uuid? {
            if (from.length != UUID_STRING_LENGTH) return null
            if (hyphenIndices.find { from[it] != '-' } != null) return null
            val bytes = ByteArray(UUID_BYTES)
            var byte = 0
            for (range in uuidCharRanges) {
                var i = range.start
                while (i < range.endInclusive) {
                    // Collect each pair of UUID chars and their int representations
                    val left = halfByteFromChar(from[i++])
                    val right = halfByteFromChar(from[i++])
                    if (left == null || right == null) return null

                    // smash them together into a single byte
                    bytes[byte++] = (left.shl(4) or right).toByte()
                }
            }
            return Uuid(bytes)
        }

        /** The ranges of sections of UUID bytes, to be separated by hyphens */
        private val uuidByteRanges: List<IntRange> = listOf(
            0 until 4,
            4 until 6,
            6 until 8,
            8 until 10,
            10 until 16
        )

        /** The UUID chars arranged from smallest to largest, so they can be indexed by their byte representations */
        internal val uuidChars = ('0'..'9') + ('a'..'f')
    }

    /**
     * Converts the UUID to a UUID string, per RFC4122
     */
    override fun toString(): String {
        val characters = CharArray(UUID_STRING_LENGTH)
        var charIndex = 0
        for (range in uuidByteRanges) {
            for (i in range) {
                val octetPair = uuid[i]
                // convert the octet pair in this byte into 2 characters
                val left = octetPair.toInt().shr(4) and 0b00001111
                val right = octetPair.toInt() and 0b00001111
                characters[charIndex++] = uuidChars[left]
                characters[charIndex++] = uuidChars[right]
            }
            if (charIndex < UUID_STRING_LENGTH) {
                characters[charIndex++] = '-'
            }
        }
        return String(characters)
    }

    /**
     * @return true if other is a UUID and its uuid bytes are equal to this one
     */
    override fun equals(other: Any?): Boolean {
        if (other !is Uuid) return false
        return other.uuid.contentEquals(uuid)
    }

    /**
     * @return The hashCode of the uuid bytes
     */
    override fun hashCode(): Int = uuid.contentHashCode()
}
